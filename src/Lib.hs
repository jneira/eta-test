{-# LANGUAGE TypeFamilies,DataKinds,FlexibleContexts,
             TypeOperators #-}

module Lib where
import Java
import Control.Exception
import Data.Either

-- ffi export using IO ()

foreign export java "@static eta.example.MyClass.sayHello" sayHelloEta :: IO ()
sayHelloEta = putStrLn "Hi"

-- ffi export using IO a

foreign export java "@static eta.example.Numbers.zero" zero :: IO Int
zero = do
 putStrLn "Returning zero from eta"
 return 0

-- ffi export using a type

foreign export java "@static eta.example.Numbers.one" one :: Int
one = 1

-- ffi export static standard

addTwo ::  Int -> Java a Int
addTwo x = return $ x + 2

foreign export java "@static eta.example.Numbers.addTwo" addTwo :: Int -> Java a Int



-- An ffi export instance method of the module! It generates a instance method for eta_test.Lib class
-- However, this can't be called from java cause the generated class has no constructors. DON'T USE THIS, it should be rejected by the compiler

foreign export java instanceMethod :: Int -> Java a Int
instanceMethod i = return $ i + 2


-- ffi export instance method for subclass

-- Importing an existing class
data JavaCounter = JavaCounter @eta.example.Counter 
   deriving Class

foreign import java unsafe "@new" newJavaCounter  :: Java a JavaCounter

-- eta.example.EtaCounter will be generated by eta
data EtaCounter = EtaCounter @eta.example.EtaCounter 
   deriving Class

-- Required to make EtaCounter a subclass of JavaCounter
type instance Inherits EtaCounter = '[JavaCounter]

-- Importing methods from JavaCounter with ( c <: JavaCounter )
-- to make it works for its subclasses (including EtaCounter)
foreign import java unsafe get :: ( c <: JavaCounter )
                               => Java c Int

foreign import java unsafe set :: ( c <: JavaCounter )
                               => Int -> Java c ()

-- implement an eta function that uses methods and state from the superclass
decrement :: Int -> Java EtaCounter Int
decrement x = do
  c <- get
  let c' = max (c - x) 0
  set c'
  return c' 

foreign export java decrement :: Int -> Java EtaCounter Int

foreign import java unsafe "@new" newEtaCounter  :: Java a EtaCounter

createAndUseEtaCounter :: Java a Int
createAndUseEtaCounter = do
  c <- newEtaCounter
  c <.> (set 10)
  c <.> get

-- ffi export static method with lambdas (Consumer)  as parameters

newtype ParseError = ParseError String

parse :: String -> Either ParseError String
parse [] = Left $ ParseError "Empty string"
parse str = Right str

data Consumer t = Consumer (@java.util.function.Consumer t)
  deriving Class

foreign import java unsafe "@interface"
  accept :: ( t <: Object ) => t -> Java (Consumer t) ()

foreign export java "@static eta_test.Lib.jparse" jparse :: JString -> Consumer JString -> Consumer JString -> Java a ()

jparse str err ok = case parse $ fromJString str of
  Left (ParseError errStr) -> err <.> (accept $ toJString errStr)
  Right str -> ok <.> (accept $ toJString str)

-- Compiler panic
-- foreign import java unsafe "@static @field eta.example.Counter.numCounters" 
--  setNumCounters :: Int -> Java a () 

foreign import java unsafe "@static @field eta.example.Counter.numCounters" 
  setNumCounters :: Int -> Java JavaCounter ()

foreign import java unsafe "@static @field eta.example.Counter.numCounters" 
  setNumCounters' :: Int -> IO()

foreign import java unsafe "@static @field eta.example.Counter.numCounters" 
  setNumCounters'' :: Int -> ()

foreign import java unsafe "@static @field eta.example.Counter.numCounters" 
  getNumCounters :: Java a Int

